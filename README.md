# Розподілене та паралельне програмування

Цей репозиторій містить лабораторну роботу, присвячену розподіленому та паралельному програмуванню. Метою проєкту є порівняння різних підходів до обчислення числа π за допомогою методів розподілених та паралельних обчислень. У цій роботі я реалізував кілька варіантів, які демонструють використання MPI, Numba та Pybind11/OpenMP для прискорення обчислень.

---

## Структура репозиторію

Репозиторій містить декілька основних файлів:

- **mpi_pi.py**  
  Скрипт, що використовує MPI (через `mpi4py`) для розподілених обчислень. Обчислення π здійснюється за допомогою інтегрального методу (метод прямокутників). Запуск цього скрипту дозволяє масштабувати обчислення на декількох процесах, що особливо корисно при наявності кластеру чи багатоядерного процесора.  
  **Приклади запуску:**  
  ```powershell
  chcp 65001
  $env:PYTHONIOENCODING = 'utf-8'
  
  mpiexec -n 4 python mpi_pi.py
  mpirun -n 4 python mpi_pi.py
  ```

- **numba_pi.py**  
  Скрипт, що демонструє використання Numba для паралельних обчислень. Використовуючи декоратори `@njit` та конструкцію `prange`, ми реалізуємо обчислення π як у послідовному, так і в паралельному режимах для двох різних методів:  
  - **Method #1 (Rectangles):** Обчислення π за формулою  
![image](https://github.com/user-attachments/assets/d9386d54-33fb-4026-81bc-6a746af82f7f)

  - **Method #2 (Quarter Circle):** Обчислення π через інтегральне обчислення площі чверті кола  
![image](https://github.com/user-attachments/assets/4f0f666a-d0bd-4258-a67f-b15dd3801a11)
 
  За допомогою аргументу командного рядка можна задати кількість потоків.  
  **Приклади запуску:**  
  ```powershell
  chcp 65001
  $env:PYTHONIOENCODING = 'utf-8'
  
  python numba_pi.py
  python numba_pi.py 8
  ```

- **combined_pi.py**  
  Цей скрипт об'єднує всі підходи в одному місці, що дозволяє порівняти результати обчислень за допомогою Numba, MPI та Pybind11/OpenMP. Скрипт запускається за допомогою однієї команди, і на виході формується дуже детальна таблиця результатів, де вказані:
  - Обчислене значення π
  - Час виконання (для серійного та паралельного режимів)
  - Різниця часу (time_diff = t_serial − t_parallel)
  - Похибка (відносно значення math.pi)
  - Показник speedup (відношення часу серійного виконання до часу паралельного виконання)  
  **Приклади запуску:**  
  - Без MPI (один процес):  
    ```bash
    python combined_pi.py 8
    ```
    (де 8 – кількість потоків)  
  - З MPI (результати MPI-методів виводяться лише з rank=0):  
    ```bash
    mpiexec -n 4 python combined_pi.py 8
    ```

- **(Опціонально) omp_pi**  
  Якщо ви використовуєте реалізацію з Pybind11/OpenMP, необхідно скомпілювати відповідний модуль (зазвичай через `setup.py`). Цей модуль реалізує обчислення π на C++ з використанням OpenMP і інтегрується в Python через pybind11. Він демонструє надзвичайно високу продуктивність при обчисленнях.

---

## Встановлення залежностей

Щоб запустити проєкт, потрібно встановити наступні пакети:

```bash
pip install numba mpi4py
```

Якщо ви плануєте використовувати модуль з Pybind11/OpenMP, встановіть також:

```bash
pip install pybind11
```

І, звісно, скомпілюйте модуль (див. інструкції у відповідному розділі).

---

## Інструкція по запуску

### Налаштування кодування
На Windows важливо налаштувати консоль для коректного відображення Unicode (UTF-8). Рекомендую виконати наступні команди у PowerShell перед запуском:

```powershell
chcp 65001
$env:PYTHONIOENCODING = 'utf-8'
```

### Запуск MPI‑скриптів
Щоб запустити MPI‑версію, використовуйте `mpiexec` або `mpirun`. Наприклад:

```powershell
mpiexec -n 4 python mpi_pi.py
```

### Запуск Numba‑скриптів
Запустіть Numba‑скрипт для тестування як послідовного, так і паралельного режиму. Наприклад:

```powershell
python numba_pi.py
python numba_pi.py 8
```

### Запуск об'єднаного скрипта
Скрипт **combined_pi.py** дозволяє порівняти всі реалізації за допомогою однієї команди. Наприклад:

- Запуск без MPI:
  ```bash
  python combined_pi.py 8
  ```
- Запуск з MPI (результати MPI‑методів виводяться лише з rank=0):
  ```bash
  mpiexec -n 4 python combined_pi.py 8
  ```

У вихідній таблиці ви побачите наступну інформацію для кожного значення \(N\):
- **Method** – назва методу (наприклад, "Numba Rectangles", "Numba QuarterCircle", "MPI Rectangles", "Pybind Rectangles" тощо).
- **Variant** – режим виконання (Serial або Parallel).
- **Pi** – обчислене значення π.
- **Time (s)** – час виконання в секундах.
- **Time Diff (s)** – різниця між часом серійного і паралельного виконання.
- **Error** – похибка обчислень відносно math.pi.
- **Speedup** – відношення часу серійного виконання до паралельного (якщо застосовно).

---

## Особистий досвід та висновки

Під час роботи над цим проєктом я експериментував із різними підходами для прискорення обчислень.  
- **MPI** дозволяє масштабувати обчислення на кластері чи багатоядерних системах, однак накладні витрати на комунікацію між процесами можуть впливати на ефективність при менших обсягах обчислень.
- **Numba** забезпечує дуже просту інтеграцію з існуючим Python‑кодом та дозволяє отримати значний приріст продуктивності за рахунок JIT-компіляції.
- **Pybind11/OpenMP** – це підхід, що дозволяє використовувати можливості C++ та OpenMP для досягнення максимальної продуктивності, що є особливо корисним при інтенсивних чисельних обчисленнях.

Кожен із підходів має свої переваги та недоліки, і в залежності від конкретних завдань можна обирати найбільш підходящий.

---

## Інструкція зі збірки модуля Pybind11/OpenMP

Якщо ви плануєте використовувати реалізацію з Pybind11/OpenMP (модуль **omp_pi**), дотримуйтесь таких кроків:
1. Переконайтесь, що встановлено pybind11:
   ```bash
   pip install pybind11
   ```
2. Використайте файл `setup.py` (знаходиться у відповідній директорії) для компіляції модуля:
   ```bash
   python setup.py build_ext --inplace
   ```
3. Переконайтесь, що скомпільований модуль з'явився у вашій директорії (файл з розширенням .pyd або .so).

---

## Підсумок

Цей проєкт демонструє різні підходи до розподілених та паралельних обчислень, що дозволяє оцінити ефективність кожного методу. Детальна таблиця результатів допомагає порівняти час виконання, похибки та швидкодію для кожного з підходів. Я сподіваюся, що цей репозиторій буде корисним для тих, хто цікавиться паралельними обчисленнями та розподіленим програмуванням.

Якщо виникнуть запитання чи потрібні уточнення, звертайтеся – я завжди відкритий до обговорення та вдосконалення!
